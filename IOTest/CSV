#!/bin/perl
use strict ;
use warnings ;

use JSON ;			## dnf install perl-JSON
use Data::Dumper ;
use File::Basename ;
use POSIX qw[strftime] ;

@ARGV or die "Usage: CSV datafile ...\n" ;

sub csv { printf /[^.0-9]/?'"%s",':'%s,', $_ for @_ ; print "\n" ; }

csv qw[
  test op filesz(MiB) blksz(KiB) dir/buf engine iodepth numjobs
  stat units meanval
  ] ;

foreach my $file (@ARGV)
  {
  next unless -s $file ;
  print STDERR "Ingesting: $file \n" ;
  my $basename = basename $file ;

  # --- read data ---

  if ($basename =~ /^fio:/)
    {
    my $test = "fio" ;
    open FIO, $file or die "Cannot open $file: $!\n" ;
    my $json ;
    while (<FIO>)
      {
      $json .= $_ if /^{/../^}/ ;
      if (/^}/)
        {
	my $fio = decode_json $json or die "Error decoding $file\n" ;
	my $device = $fio->{"global options"}{filename} ;
	my $timestamp = strftime "%F %T", localtime $fio->{timestamp} ;

	for my $job (@{$fio->{jobs}})
	  {
	  my $jobname = $job->{jobname} ;
	  die "Error in job [$jobname]\n" if $job->{error} ;

	  ## Job Options:
	  my $jo = $job->{"job options"} ;
	  my $go = $fio->{"global options"} ;
	  my $rw      = $jo->{rw}       || $go->{rw} ;       ## read
	  my $engine  = $jo->{ioengine} || $go->{ioengine} ; ## sync
	  my $size    = $jo->{size}     || $go->{size} ;     ## 1024M
	  my $iodepth = $jo->{iodepth}  || $go->{iodepth} ;  ## 1
	  my $direct  = $jo->{direct}   || $go->{direct} ;   ## 1
	  my $db      = $direct ? "direct" : "buffered" ;
	  my $bs      = $jo->{bs}       || $go->{bs} ;       ## 4k
	  my $numjobs = $jo->{numjobs}  || $go->{numjobs} ;  ## 1

	  my $rwx = $rw =~ /write$/ ? "write" : "read" ;
	  $size =~ s/M$// ;
	  $bs   =~ s/k$// ;

	  my @csv = ($test,$rw,$size,$bs,$db,$engine,$iodepth,$numjobs) ;

	  my ($min, $max, $mean, $stddev, $count) ;

	  ## if ($stat eq "bw") # GB/s
	    {
	    my $s	= 1024/1_000_000_000 ;			# KiB/s
	    $min	= $s*$job->{$rwx}{bw_min} ;		# 2084864
	    $max	= $s*$job->{$rwx}{bw_max} ;		# 2648064
	    $mean	= $s*$job->{$rwx}{bw_mean} ;		# 2365096.9456
	    $stddev	= $s*$job->{$rwx}{bw_dev} ;		# 2369.756549
	    $count	=    $job->{$rwx}{bw_samples} ;		# 5728
	    csv @csv, 'bw', 'GB/s', $mean ;
	    }

	  ## elsif ($stat eq "iops") # kIOPS
	    {
	    my $s	= 1/1_000 ;				# IOPS
	    $min	= $s*$job->{$rwx}{iops_min} ;		# 2036
	    $max	= $s*$job->{$rwx}{iops_max} ;		# 2586
	    $mean	= $s*$job->{$rwx}{iops_mean} ;		# 2309.6649
	    $stddev	= $s*$job->{$rwx}{iops_stddev} ;	# 2.314215
	    $count	=    $job->{$rwx}{iops_samples} ;	# 5728
	    csv @csv, 'iops', 'kIOPS', $mean ;
	    }

	  ## elsif ($stat eq "lat") # usec
	    {
	    my $s	= 1/1000 ;				# ns
	    $min	= $s*$job->{$rwx}{lat_ns}{min} ;	# 107333
	    $max	= $s*$job->{$rwx}{lat_ns}{max} ;	# 61317713
	    $mean	= $s*$job->{$rwx}{lat_ns}{mean} ;	# 20783212.9199
	    $stddev	= $s*$job->{$rwx}{lat_ns}{stddev} ;	# 14398279.8821
	    $count	=    $job->{$rwx}{lat_ns}{N} ;		# 138603
	    csv @csv, 'lat', 'usec', $mean ;
	    }

	  ## elsif ($stat eq "clat") # usec
	    {
	    my $s	= 1/1000 ;				# ns
	    $min	= $s*$job->{$rwx}{clat_ns}{min} ;	# 107333
	    $max	= $s*$job->{$rwx}{clat_ns}{max} ;	# 61317713
	    $mean	= $s*$job->{$rwx}{clat_ns}{mean} ;	# 20783212.9199
	    $stddev	= $s*$job->{$rwx}{clat_ns}{stddev} ;	# 14398279.8821
	    $count	=    $job->{$rwx}{clat_ns}{N} ;		# 138603
	    csv @csv, 'clat', 'usec', $mean ;
	    }

	  ## elsif ($stat eq "slat") # usec
	    {
	    my $s	= 1/1000 ;				# ns
	    $min	= $s*$job->{$rwx}{slat_ns}{min} ;	# 107333
	    $max	= $s*$job->{$rwx}{slat_ns}{max} ;	# 61317713
	    $mean	= $s*$job->{$rwx}{slat_ns}{mean} ;	# 20783212.9199
	    $stddev	= $s*$job->{$rwx}{slat_ns}{stddev} ;	# 14398279.8821
	    $count	=    $job->{$rwx}{slat_ns}{N} ;		# 138603
	    csv @csv, 'slat', 'usec', $mean ;
	    }
	  }

        $json = "" ;
	}
      }
    close FIO ;
    }

  else  { die "Unknown file type: $file\n" ; }
  }

__END__ # =====================================================================
__END__ # =====================================================================
__END__ # =====================================================================

  # --- make plot file ---

  next unless %data ;

  my $tag = $file ;
  $tag =~ s|/|-|g ;
  $tag =~ s|\.out$|| ;
  push @pd, my $pd = "$pdir/$tag.pd" ;

  open PD, ">", $pd or die "Cannot open $pd: $!\n" ;
  for my $th (sort {$a<=>$b} keys %data)
    {
    my @data = @{$data{$th}} ;
    my $sum  = 0 ; $sum += $_ for @data ;
    my $mean = $sum/@data ;
    my $sumdevsq  = 0 ; $sumdevsq += ($_-$mean)**2 for @data ;
    my $stddev = sqrt( $sumdevsq/@data );
    printf PD "%d %f %f\n", $th, $mean, $stddev ;
    }
  close PD or die "Error closing $pd $!\n" ;

  }

__END__ # =====================================================================
__END__ # =====================================================================
__END__ # =====================================================================

