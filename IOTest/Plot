#!/bin/perl
use strict ;
use warnings ;

use JSON ;			## dnf install perl-JSON
use Data::Dumper ;
use File::Basename ;
use POSIX qw[strftime] ;

my @pd ; # plot files
my $pdir = "/run/user/$</plotdata" ;
if (!-d $pdir) { mkdir $pdir or die "Cannot mkdir $pdir: $!\n" ; }

@ARGV or die "Usage: Plot bw|iops|lat datafile ...\n" ;

my $stat = shift @ARGV ;
my %stat = map { $_, 1 } qw [ bw iops lat clat slat bir lir clr slr cslr ] ;
die "Bad statistic request: $stat!\n" unless $stat{$stat} ;

foreach my $file (@ARGV)
  {
  next unless -s $file ;
  print "Ingesting: $file \n" ;
  my $basename = basename $file ;

  my %data ; ## @{$Data{$th}} = data points for $th threads

  # --- read data ---

  if ($basename =~ /^ddr:/)
    {
    next unless $stat eq "bw" ;
    open DDR, "<", $file or die "Cannot open $file: $!\n" ;
    while (<DDR>)
      {
      chomp ;
      next unless /^Aggregate/ ;
      /^Aggregate (\d+) Th \s*([.\d]+) GBps/
	or die "Bad data line! ($file:$.)\n>> $_\n" ;
      push @{$data{$1}}, $2 ;
      }
    close DDR ;
    }

  elsif ($basename =~ /^fio:/)
    {
    open FIO, $file or die "Cannot open $file: $!\n" ;
    my $json ;
    while (<FIO>)
      {
      $json .= $_ if /^{/../^}/ ;
      if (/^}/)
        {
	my $fio = decode_json $json or die "Error decoding $file\n" ;
	my $device = $fio->{"global options"}{filename} ;
	my $timestamp = strftime "%F %T", localtime $fio->{timestamp} ;

	for my $job (@{$fio->{jobs}})
	  {
	  my $jobname = $job->{jobname} ; ## print "Job: [$jobname]\n" ;
	  die "Error in job [$jobname]\n" if $job->{error} ;

	  ## Job Options:
	  my $jo = $job->{"job options"} ;
	  my $go = $fio->{"global options"} ;
	  my $rw      = $jo->{rw}       || $go->{rw} ;       ## read
	  my $engine  = $jo->{ioengine} || $go->{ioengine} ; ## sync
	  my $iodepth = $jo->{iodepth}  || $go->{iodepth} ;  ## 1
	  my $direct  = $jo->{direct}   || $go->{direct} ;   ## 1
	  my $bs      = $jo->{bs}       || $go->{bs} ;       ## 4k
	  my $numjobs = $jo->{numjobs}  || $go->{numjobs} ;  ## 1

	  my $rwx = $rw =~ /write$/ ? "write" : "read" ;

	  my ($min, $max, $mean, $stddev, $count) ;

	  if ($stat eq "bw") # GB/s
	    {
	    my $s	= 1024/1_000_000_000 ;			# KiB/s
	    $min	= $s*$job->{$rwx}{bw_min} ;		# 2084864
	    $max	= $s*$job->{$rwx}{bw_max} ;		# 2648064
	    $mean	= $s*$job->{$rwx}{bw_mean} ;		# 2365096.9456
	    $stddev	= $s*$job->{$rwx}{bw_dev} ;		# 2369.756549
	    $count	=    $job->{$rwx}{bw_samples} ;		# 5728
	    }

	  elsif ($stat eq "iops") # kIOPS
	    {
	    my $s	= 1/1_000 ;				# IOPS
	    $min	= $s*$job->{$rwx}{iops_min} ;		# 2036
	    $max	= $s*$job->{$rwx}{iops_max} ;		# 2586
	    $mean	= $s*$job->{$rwx}{iops_mean} ;		# 2309.6649
	    $stddev	= $s*$job->{$rwx}{iops_stddev} ;	# 2.314215
	    $count	=    $job->{$rwx}{iops_samples} ;	# 5728
	    }

	  elsif ($stat eq "lat") # usec
	    {
	    my $s	= 1/1000 ;				# ns
	    $min	= $s*$job->{$rwx}{lat_ns}{min} ;	# 107333
	    $max	= $s*$job->{$rwx}{lat_ns}{max} ;	# 61317713
	    $mean	= $s*$job->{$rwx}{lat_ns}{mean} ;	# 20783212.9199
	    $stddev	= $s*$job->{$rwx}{lat_ns}{stddev} ;	# 14398279.8821
	    $count	=    $job->{$rwx}{lat_ns}{N} ;		# 138603
	    }

	  elsif ($stat eq "clat") # usec
	    {
	    my $s	= 1/1000 ;				# ns
	    $min	= $s*$job->{$rwx}{clat_ns}{min} ;	# 107333
	    $max	= $s*$job->{$rwx}{clat_ns}{max} ;	# 61317713
	    $mean	= $s*$job->{$rwx}{clat_ns}{mean} ;	# 20783212.9199
	    $stddev	= $s*$job->{$rwx}{clat_ns}{stddev} ;	# 14398279.8821
	    $count	=    $job->{$rwx}{clat_ns}{N} ;		# 138603
	    }

	  elsif ($stat eq "slat") # usec
	    {
	    my $s	= 1/1000 ;				# ns
	    $min	= $s*$job->{$rwx}{slat_ns}{min} ;	# 107333
	    $max	= $s*$job->{$rwx}{slat_ns}{max} ;	# 61317713
	    $mean	= $s*$job->{$rwx}{slat_ns}{mean} ;	# 20783212.9199
	    $stddev	= $s*$job->{$rwx}{slat_ns}{stddev} ;	# 14398279.8821
	    $count	=    $job->{$rwx}{slat_ns}{N} ;		# 138603
	    }

	  elsif ($stat eq "bir") #
	    {
	    my $bw	= $job->{$rwx}{bw_mean} ;		# 2365096.9456
	    my $iops	= $job->{$rwx}{iops_mean} ;		# 2309.6649
	    die "Bad bs: [$bs]\n" unless $bs =~ /^(\d+)k$/ ;
	    my $blksz	= $1 ;
	    $mean	= $bw / ( $blksz * $iops ) ;
	    }

	  elsif ($stat eq "lir") #
	    {
	    my $iops	= $job->{$rwx}{iops_mean} ;		# 2309.6649
	    my $lat	= $job->{$rwx}{lat_ns}{mean} ;		# 20783212.9199
	    $mean	= $iops * $lat / $numjobs / $iodepth / 10**9 ; 
	    }

	  elsif ($stat eq "clr") #
	    {
	    my $lat	= $job->{$rwx}{lat_ns}{mean} ;		# 20783212.9199
	    my $clat	= $job->{$rwx}{clat_ns}{mean} ;		# 20783212.9199
	    my $slat	= $job->{$rwx}{slat_ns}{mean} ;		# 20783212.9199
	    $mean	= $clat / $lat ;
	    }

	  elsif ($stat eq "slr") #
	    {
	    my $lat	= $job->{$rwx}{lat_ns}{mean} ;		# 20783212.9199
	    my $clat	= $job->{$rwx}{clat_ns}{mean} ;		# 20783212.9199
	    my $slat	= $job->{$rwx}{slat_ns}{mean} ;		# 20783212.9199
	    $mean	= $slat / $lat ;
	    }

	  elsif ($stat eq "cslr") #
	    {
	    my $lat	= $job->{$rwx}{lat_ns}{mean} ;		# 20783212.9199
	    my $clat	= $job->{$rwx}{clat_ns}{mean} ;		# 20783212.9199
	    my $slat	= $job->{$rwx}{slat_ns}{mean} ;		# 20783212.9199
	    $mean	= ( $clat + $slat ) / $lat ;
	    }

	  push @{$data{$numjobs}}, $mean ;
	  }

        $json = "" ;
	}
      }
    close FIO ;
    }

  else  { die "Unknown file type: $file\n" ; }

  # --- make plot file ---

  next unless %data ;

  my $tag = $file ;
  $tag =~ s|/|-|g ;
  $tag =~ s|\.out$|| ;
  push @pd, my $pd = "$pdir/$tag.pd" ;

  open PD, ">", $pd or die "Cannot open $pd: $!\n" ;
  for my $th (sort {$a<=>$b} keys %data)
    {
    my @data = @{$data{$th}} ;
    my $sum  = 0 ; $sum += $_ for @data ;
    my $mean = $sum/@data ;
    my $sumdevsq  = 0 ; $sumdevsq += ($_-$mean)**2 for @data ;
    my $stddev = sqrt( $sumdevsq/@data );
    printf PD "%d %f %f\n", $th, $mean, $stddev ;
    }
  close PD or die "Error closing $pd $!\n" ;

  }

# --- invoke gnuplot to plot data ---

#foreach (@pd)
#  {
#  print "DATA: $_\n" ;
#  system "/bin/cat", $_ ;
#  }

die "No data to plot!\n" unless @pd ;

if (1) { open GP, "|gnuplot" or die "Cannot open |gnuplot: $!\n" ; }
else   { open GP, "|cat" ; }

my $ylabel = "???" ;
my $xrange = "[0:8<*]" ;
my $ycap = 0 ;
my $yrange ;

if ($stat eq "bw")
  {
  $ylabel = "Bandwidth GB/s" ;
  $yrange = "[0:*]" ;
  $ycap   = 15.0 ; # PCIe Bandwidth
  }

elsif ($stat eq "iops")
  {
  $ylabel = "kIOPS" ;
  $yrange = "[0:*]" ;
  $ycap   = 168 ; # Exos X24 Random Read IOPS 
  }

elsif ($stat eq "lat")
  {
  $ylabel = "Latency us" ;
  $yrange = "[0:*]" ;
  }

elsif ($stat eq "clat")
  {
  $ylabel = "C-Latency us" ;
  $yrange = "[0:*]" ;
  }

elsif ($stat eq "slat")
  {
  $ylabel = "S-Latency us" ;
  $yrange = "[0:*]" ;
  }

elsif ($stat eq "bir")
  {
  $ylabel = "BW / ( BS * IOPS )" ;
  $yrange = "[*<0.99:1.01<*]" ;
  }

elsif ($stat eq "lir")
  {
  $ylabel = "Lat * IOPS / NumJobs / IODepth" ;
  $yrange = "[*<0.99:1.01<*]" ;
  }

elsif ($stat eq "clr")
  {
  $ylabel = "C-Lat / Lat" ;
  $yrange = "[*<0.99:1.01<*]" ;
  }

elsif ($stat eq "slr")
  {
  $ylabel = "S-Lat / Lat" ;
  $yrange = "[*<0.99:1.01<*]" ;
  }

elsif ($stat eq "cslr")
  {
  $ylabel = "( C-Lat + S-Lat ) / Lat" ;
  $yrange = "[*<0.99:1.01<*]" ;
  }

else { die "Unknown statistic: $stat\n" ; }

use Cwd ;
my $title = basename getcwd ;

print GP <<EOD ;
set title "$title"
set key outside right
set key title Left reverse
set term png size 600,400
set term png size 1200,800
set output 'plot.png'
set xlabel "Concurrent jobs"
set ylabel "$ylabel"
set style line 99 lc rgb "#eeeeee"
set grid ls 99
set xrange $xrange
\$linear<<EOI
0 0
63.2 18.0
EOI
\$ycap<<EOI
0  $ycap
80 $ycap
EOI
set linetype 98 pt 5 lw 1 lc rgb 'grey'
set linetype 99 pt 5 lw 1 lc rgb '#00BB00'
EOD
print GP "set yrange $yrange\n" if $yrange ;

for (my $l=1 ; $l <= @pd ; $l++)
  {
  print GP "set linetype $l pt 5\n" ;
  }

print GP "plot \\\n" ;
for (@pd)
  {
  my $title = basename $_, ".pd" ;
  print GP "'$_' with errorlines title '$title' , \\\n" ;
  }

if ($ycap)
  {
  print GP "\$ycap with lines lt 99 notitle noautoscale, \\\n" ;
  }

if ($stat eq "bw")
  {
  print GP "\$linear with lines lt 98 notitle noautoscale, \\\n" ;
  }

print GP "\n" ;
close GP ;

__END__ # =====================================================================
__END__ # =====================================================================
__END__ # =====================================================================

